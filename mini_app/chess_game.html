<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö–º–∞—Ç—ã —Å –Ø–∫–æ–≤–æ–º –î–∞–≤–∏–¥–æ–≤–∏—á–µ–º</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--tg-theme-bg-color, #1a1a1a);
            color: var(--tg-theme-text-color, #ffffff);
            padding: 16px;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 16px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            border-radius: 12px;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .header p {
            opacity: 0.8;
            font-size: 14px;
        }

        /* –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–≥—Ä—ã */
        .setup-screen {
            max-width: 400px;
            margin: 0 auto;
        }

        .setup-section {
            background: var(--tg-theme-secondary-bg-color, #2a2a2a);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .setup-section h3 {
            margin-bottom: 16px;
            color: var(--tg-theme-button-color, #3390ec);
        }

        .difficulty-grid {
            display: grid;
            gap: 12px;
        }

        .difficulty-btn, .color-btn {
            padding: 16px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: var(--tg-theme-button-color, #3390ec);
            color: var(--tg-theme-button-text-color, #ffffff);
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .difficulty-btn:hover, .color-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(51, 144, 236, 0.3);
        }

        .difficulty-btn.selected, .color-btn.selected {
            border-color: #f39c12;
            background: #e67e22;
        }

        .difficulty-level {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .difficulty-desc {
            font-size: 14px;
            opacity: 0.8;
        }

        .color-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .color-btn {
            text-align: center;
        }

        .color-pieces {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .start-btn {
            width: 100%;
            padding: 16px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }

        .start-btn:hover {
            background: #219a52;
        }

        .start-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        /* –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω */
        .game-screen {
            display: none;
        }

        .game-info {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 16px;
            margin-bottom: 20px;
            padding: 16px;
            background: var(--tg-theme-secondary-bg-color, #2a2a2a);
            border-radius: 12px;
        }

        .player-info {
            text-align: center;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .player-color {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .captured-pieces {
            font-size: 16px;
            min-height: 20px;
        }

        .game-status {
            text-align: center;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
        }

        .status-your-turn {
            background: #27ae60;
        }

        .status-ai-turn {
            background: #e74c3c;
        }

        .status-thinking {
            background: #f39c12;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* –®–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞ */
        .chess-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .chess-board {
            width: 320px;
            height: 320px;
            border: 4px solid #8b4513;
            border-radius: 8px;
            position: relative;
            background: #d4931a;
        }

        .board-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            user-select: none;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square:hover {
            background-color: #7fb069 !important;
        }

        .square.selected {
            background-color: #7fb069 !important;
            box-shadow: inset 0 0 0 3px #4a7c59;
        }

        .square.possible-move {
            background-color: rgba(127, 176, 105, 0.5) !important;
        }

        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #2d5a32;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 32px;
            height: 32px;
            border: 3px solid #d32f2f;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: none;
        }

        .square.last-move {
            background-color: rgba(255, 255, 0, 0.3) !important;
        }

        .piece {
            cursor: grab;
            transition: transform 0.2s;
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .piece-white {
            color: #ffffff;
            text-shadow: 1px 1px 0 #000000, -1px -1px 0 #000000, 
                         1px -1px 0 #000000, -1px 1px 0 #000000;
        }

        .piece-black {
            color: #000000;
            text-shadow: 1px 1px 0 #ffffff, -1px -1px 0 #ffffff, 
                         1px -1px 0 #ffffff, -1px 1px 0 #ffffff;
        }

        /* –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–æ—Å–∫–∏ */
        .board-coords {
            position: absolute;
            color: #8b4513;
            font-weight: bold;
            font-size: 12px;
        }

        .coord-file {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .coord-rank {
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* –ö–æ–Ω—Ç—Ä–æ–ª—ã –∏–≥—Ä—ã */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--tg-theme-button-color, #3390ec);
            color: var(--tg-theme-button-text-color, #ffffff);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            opacity: 0.9;
        }

        /* –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –Ø–∫–æ–≤–∞ */
        .yakov-comment {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border-left: 4px solid #3498db;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            font-style: italic;
            position: relative;
        }

        .yakov-comment:before {
            content: "üë¥";
            position: absolute;
            top: -8px;
            left: 16px;
            background: #2c3e50;
            padding: 0 8px;
        }

        /* –ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤ */
        .move-history {
            background: var(--tg-theme-secondary-bg-color, #2a2a2a);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            max-height: 150px;
            overflow-y: auto;
        }

        .move-history h4 {
            margin-bottom: 12px;
            color: var(--tg-theme-button-color, #3390ec);
        }

        .move-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-family: monospace;
        }

        .move-item {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 14px;
        }

        /* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
        @media (max-width: 480px) {
            .chess-board {
                width: 280px;
                height: 280px;
            }
            
            .square {
                font-size: 24px;
            }
            
            .game-info {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .game-controls {
                flex-wrap: wrap;
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>‚ôüÔ∏è –®–∞—Ö–º–∞—Ç—ã —Å –Ø–∫–æ–≤–æ–º –î–∞–≤–∏–¥–æ–≤–∏—á–µ–º</h1>
        <p>–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω–∞—è –ø–∞—Ä—Ç–∏—è –ø—Ä–æ—Ç–∏–≤ –ò–ò</p>
    </div>

    <!-- –≠–∫—Ä–∞–Ω –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ -->
    <div id="setup-screen" class="setup-screen">
        <div class="setup-section">
            <h3>üéØ –í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å</h3>
            <div class="difficulty-grid" id="difficulty-grid">
                <!-- –ö–Ω–æ–ø–∫–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ JS -->
            </div>
        </div>

        <div class="setup-section">
            <h3>üé® –í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç —Ñ–∏–≥—É—Ä</h3>
            <div class="color-grid">
                <div class="color-btn" data-color="white">
                    <div class="color-pieces">‚ôî‚ôï‚ôñ‚ôó‚ôò‚ôô</div>
                    <div>–ë–µ–ª—ã–µ</div>
                    <div style="font-size: 12px; opacity: 0.8;">–ü–µ—Ä–≤—ã–π —Ö–æ–¥</div>
                </div>
                <div class="color-btn" data-color="black">
                    <div class="color-pieces">‚ôö‚ôõ‚ôú‚ôù‚ôû‚ôü</div>
                    <div>–ß–µ—Ä–Ω—ã–µ</div>
                    <div style="font-size: 12px; opacity: 0.8;">–ö–ª–∞—Å—Å–∏–∫–∞</div>
                </div>
            </div>
        </div>

        <button class="start-btn" id="start-game-btn" disabled>üöÄ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
    </div>

    <!-- –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω -->
    <div id="game-screen" class="game-screen">
        <div class="game-info">
            <div class="player-info">
                <div class="player-name">–í—ã</div>
                <div class="player-color" id="player-color">‚ôî</div>
                <div class="captured-pieces" id="player-captured"></div>
            </div>
            
            <div class="game-status" id="game-status">–í–∞—à —Ö–æ–¥!</div>
            
            <div class="player-info">
                <div class="player-name">–Ø–∫–æ–≤ –ò–ò</div>
                <div class="player-color" id="ai-color">‚ôö</div>
                <div class="captured-pieces" id="ai-captured"></div>
            </div>
        </div>

        <div class="chess-container">
            <div class="chess-board" id="chess-board">
                <div class="board-grid" id="board-grid">
                    <!-- –ö–ª–µ—Ç–∫–∏ –¥–æ—Å–∫–∏ –±—É–¥—É—Ç —Å–æ–∑–¥–∞–Ω—ã —á–µ—Ä–µ–∑ JS -->
                </div>
            </div>
        </div>

        <div class="game-controls">
            <button class="control-btn btn-secondary" onclick="showMoveHistory()">üìú –ò—Å—Ç–æ—Ä–∏—è</button>
            <button class="control-btn btn-primary" onclick="requestHint()">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
            <button class="control-btn btn-danger" onclick="resignGame()">üè≥Ô∏è –°–¥–∞—Ç—å—Å—è</button>
        </div>

        <div class="move-history hidden" id="move-history">
            <h4>üìú –ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤</h4>
            <div class="move-list" id="move-list">
                <!-- –•–æ–¥—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ JS -->
            </div>
        </div>

        <div class="yakov-comment" id="yakov-comment">
            "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞—Ä—Ç–∏—é, —Ç–æ–≤–∞—Ä–∏—â! –ö–∞–∫ –≥–æ–≤–æ—Ä–∏—Ç—Å—è, –∫–∞–∂–¥–∞—è –∏–≥—Ä–∞ - —ç—Ç–æ —É—Ä–æ–∫."
        </div>
    </div>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram Web App
        let tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–º—É Telegram
        document.body.style.backgroundColor = tg.backgroundColor || '#1a1a1a';

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä—ã
        let gameState = {
            difficulty: null,
            playerColor: null,
            board: null,
            currentTurn: 'white',
            selectedSquare: null,
            possibleMoves: [],
            moveHistory: [],
            gameStatus: 'setup',
            capturedPieces: { white: [], black: [] }
        };

        // Unicode —Ñ–∏–≥—É—Ä—ã
        const pieces = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // –£—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
        const difficulties = [
            { id: 'beginner', name: '–ù–æ–≤–∏—á–æ–∫', level: 1, desc: '–î–ª—è —Ç–µ—Ö, –∫—Ç–æ —Ç–æ–ª—å–∫–æ —É—á–∏—Ç—Å—è' },
            { id: 'easy', name: '–õ–µ–≥–∫–∏–π', level: 3, desc: '–ü—Ä–æ—Å—Ç—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏' },
            { id: 'medium', name: '–°—Ä–µ–¥–Ω–∏–π', level: 5, desc: '–¢–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏' },
            { id: 'hard', name: '–°–ª–æ–∂–Ω—ã–π', level: 7, desc: '–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–µ –º—ã—à–ª–µ–Ω–∏–µ' },
            { id: 'expert', name: '–≠–∫—Å–ø–µ—Ä—Ç', level: 9, desc: '–ö–∞–∫ –Ø–∫–æ–≤ –≤ –º–æ–ª–æ–¥–æ—Å—Ç–∏!' }
        ];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', function() {
            initializeDifficultyButtons();
            initializeColorSelection();
            initializeBoard();
        });

        function initializeDifficultyButtons() {
            const difficultyGrid = document.getElementById('difficulty-grid');
            
            difficulties.forEach(diff => {
                const button = document.createElement('div');
                button.className = 'difficulty-btn';
                button.dataset.difficulty = diff.id;
                button.innerHTML = `
                    <div class="difficulty-level">${diff.name} (–£—Ä–æ–≤–µ–Ω—å ${diff.level})</div>
                    <div class="difficulty-desc">${diff.desc}</div>
                `;
                
                button.addEventListener('click', () => selectDifficulty(diff.id));
                difficultyGrid.appendChild(button);
            });
        }

        function initializeColorSelection() {
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => selectColor(btn.dataset.color));
            });
        }

        function selectDifficulty(difficultyId) {
            // –£–±–∏—Ä–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –¥—Ä—É–≥–∏—Ö –∫–Ω–æ–ø–æ–∫
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // –í—ã–¥–µ–ª—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—É—é –∫–Ω–æ–ø–∫—É
            document.querySelector(`[data-difficulty="${difficultyId}"]`).classList.add('selected');
            
            gameState.difficulty = difficultyId;
            updateStartButton();
        }

        function selectColor(color) {
            // –£–±–∏—Ä–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –¥—Ä—É–≥–∏—Ö –∫–Ω–æ–ø–æ–∫
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // –í—ã–¥–µ–ª—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—É—é –∫–Ω–æ–ø–∫—É
            document.querySelector(`[data-color="${color}"]`).classList.add('selected');
            
            gameState.playerColor = color;
            updateStartButton();
        }

        function updateStartButton() {
            const startBtn = document.getElementById('start-game-btn');
            const canStart = gameState.difficulty && gameState.playerColor;
            
            startBtn.disabled = !canStart;
            if (canStart) {
                startBtn.onclick = startGame;
            }
        }

        function startGame() {
            try {
                console.log('üöÄ –ù–∞—á–∏–Ω–∞–µ–º –∏–≥—Ä—É...');
                
                // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –∏–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω
                document.getElementById('setup-screen').classList.add('hidden');
                document.getElementById('game-screen').classList.remove('hidden');
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–≥—Ä—É
                gameState.board = initialBoard.map(row => [...row]);
                gameState.gameStatus = 'playing';
                gameState.currentTurn = 'white';
                
                console.log('‚úÖ –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ');
                
                // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
                setupGameInterface();
                renderBoard();
                
                console.log('‚úÖ –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –Ω–∞—Å—Ç—Ä–æ–µ–Ω');
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –æ –Ω–∞—á–∞–ª–µ –∏–≥—Ä—ã –≤ –±–æ—Ç
                if (tg && tg.sendData) {
                    try {
                        tg.sendData(JSON.stringify({
                            action: 'start_game',
                            difficulty: gameState.difficulty,
                            playerColor: gameState.playerColor
                        }));
                        console.log('‚úÖ –î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ –±–æ—Ç');
                    } catch (sendError) {
                        console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö:', sendError);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Telegram WebApp –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                }
                
            } catch (error) {
                console.error('‚ùå –û—à–∏–±–∫–∞ –≤ startGame():', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã: ' + error.message);
            }
            
            // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –∏–≥—Ä–∞–µ—Ç —á–µ—Ä–Ω—ã–º–∏, –ò–ò —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º
            if (gameState.playerColor === 'black') {
                setTimeout(requestAIMove, 1000);
            }
        }

        function setupGameInterface() {
            const playerColorEl = document.getElementById('player-color');
            const aiColorEl = document.getElementById('ai-color');
            
            if (gameState.playerColor === 'white') {
                playerColorEl.textContent = '‚ôî';
                aiColorEl.textContent = '‚ôö';
            } else {
                playerColorEl.textContent = '‚ôö';
                aiColorEl.textContent = '‚ôî';
            }
            
            updateGameStatus();
        }

        function initializeBoard() {
            const boardGrid = document.getElementById('board-grid');
            boardGrid.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                    if (col === 0) {
                        const rankLabel = document.createElement('div');
                        rankLabel.className = 'board-coords coord-rank';
                        rankLabel.textContent = 8 - row;
                        square.appendChild(rankLabel);
                    }
                    if (row === 7) {
                        const fileLabel = document.createElement('div');
                        fileLabel.className = 'board-coords coord-file';
                        fileLabel.textContent = String.fromCharCode(97 + col); // a-h
                        square.appendChild(fileLabel);
                    }
                    
                    boardGrid.appendChild(square);
                }
            }
        }

        function renderBoard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    const piece = gameState.board[row][col];
                    
                    // –û—á–∏—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (–∫—Ä–æ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç)
                    const coords = square.querySelectorAll('.board-coords');
                    square.innerHTML = '';
                    coords.forEach(coord => square.appendChild(coord));
                    
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece ${piece === piece.toUpperCase() ? 'piece-white' : 'piece-black'}`;
                        pieceEl.textContent = pieces[piece];
                        square.appendChild(pieceEl);
                    }
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameState.gameStatus !== 'playing') return;
            if (gameState.currentTurn !== gameState.playerColor) return;
            
            const piece = gameState.board[row][col];
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è
            clearHighlights();
            
            // –ï—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ —Å–≤–æ—é —Ñ–∏–≥—É—Ä—É
            if (piece && isPieceOurs(piece)) {
                gameState.selectedSquare = { row, col };
                square.classList.add('selected');
                
                // –ü–æ–ª—É—á–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
                gameState.possibleMoves = calculatePossibleMoves(row, col, piece);
                highlightPossibleMoves();
                
            } else if (gameState.selectedSquare) {
                // –ü—ã—Ç–∞–µ–º—Å—è —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥
                const moveValid = gameState.possibleMoves.some(
                    move => move.row === row && move.col === col
                );
                
                if (moveValid) {
                    makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                    gameState.selectedSquare = null;
                    gameState.possibleMoves = [];
                } else {
                    // –ù–µ–≤–µ—Ä–Ω—ã–π —Ö–æ–¥
                    updateYakovComment("–≠—Ç–æ—Ç —Ö–æ–¥ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω, —Ç–æ–≤–∞—Ä–∏—â! –ò–∑—É—á–∞–π—Ç–µ –ø—Ä–∞–≤–∏–ª–∞ —à–∞—Ö–º–∞—Ç.");
                }
            }
        }

        function isPieceOurs(piece) {
            const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
            return pieceColor === gameState.playerColor;
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move', 'possible-capture', 'last-move');
            });
        }

        function highlightPossibleMoves() {
            gameState.possibleMoves.forEach(move => {
                const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                const targetPiece = gameState.board[move.row][move.col];
                
                if (targetPiece) {
                    square.classList.add('possible-capture');
                } else {
                    square.classList.add('possible-move');
                }
            });
        }

        function calculatePossibleMoves(row, col, piece) {
            const moves = [];
            const pieceType = piece.toLowerCase();
            const isWhite = piece === piece.toUpperCase();
            
            switch (pieceType) {
                case 'p': // –ü–µ—à–∫–∞
                    moves.push(...getPawnMoves(row, col, isWhite));
                    break;
                case 'r': // –õ–∞–¥—å—è
                    moves.push(...getLineMoves(row, col, [[0,1], [0,-1], [1,0], [-1,0]], isWhite));
                    break;
                case 'b': // –°–ª–æ–Ω
                    moves.push(...getLineMoves(row, col, [[1,1], [1,-1], [-1,1], [-1,-1]], isWhite));
                    break;
                case 'q': // –§–µ—Ä–∑—å
                    moves.push(...getLineMoves(row, col, [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]], isWhite));
                    break;
                case 'n': // –ö–æ–Ω—å
                    moves.push(...getKnightMoves(row, col, isWhite));
                    break;
                case 'k': // –ö–æ—Ä–æ–ª—å
                    moves.push(...getKingMoves(row, col, isWhite));
                    break;
            }
            
            return moves;
        }

        function getPawnMoves(row, col, isWhite) {
            const moves = [];
            const direction = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;
            
            // –•–æ–¥ –≤–ø–µ—Ä–µ–¥
            const newRow = row + direction;
            if (newRow >= 0 && newRow < 8 && !gameState.board[newRow][col]) {
                moves.push({ row: newRow, col });
                
                // –î–≤–æ–π–Ω–æ–π —Ö–æ–¥ —Å –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
                if (row === startRow && !gameState.board[newRow + direction][col]) {
                    moves.push({ row: newRow + direction, col });
                }
            }
            
            // –í–∑—è—Ç–∏–µ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
            [-1, 1].forEach(dc => {
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = gameState.board[newRow][newCol];
                    if (target && (target.isupper !== isWhite)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });
            
            return moves;
        }

        function getLineMoves(row, col, directions, isWhite) {
            const moves = [];
            
            directions.forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                    
                    const target = gameState.board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if ((target === target.toUpperCase()) !== isWhite) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            });
            
            return moves;
        }

        function getKnightMoves(row, col, isWhite) {
            const moves = [];
            const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
            
            knightMoves.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = gameState.board[newRow][newCol];
                    if (!target || (target === target.toUpperCase()) !== isWhite) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });
            
            return moves;
        }

        function getKingMoves(row, col, isWhite) {
            const moves = [];
            const kingMoves = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            
            kingMoves.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = gameState.board[newRow][newCol];
                    if (!target || (target === target.toUpperCase()) !== isWhite) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });
            
            return moves;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // –í—ã–ø–æ–ª–Ω—è–µ–º —Ö–æ–¥
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = '';
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤–∑—è—Ç—É—é —Ñ–∏–≥—É—Ä—É
            if (capturedPiece) {
                const capturedColor = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';
                gameState.capturedPieces[capturedColor].push(capturedPiece);
                updateCapturedPieces();
            }
            
            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ö–æ–¥ –≤ –∏—Å—Ç–æ—Ä–∏—é
            const moveNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}-${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            gameState.moveHistory.push({
                notation: moveNotation,
                piece,
                captured: capturedPiece,
                player: gameState.playerColor
            });
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ö–æ–¥
            document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`).classList.add('last-move');
            
            // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –¥–æ—Å–∫—É
            renderBoard();
            
            // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ö–æ–¥
            gameState.currentTurn = gameState.currentTurn === 'white' ? 'black' : 'white';
            updateGameStatus();
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ö–æ–¥ –≤ –±–æ—Ç
            if (tg && tg.sendData) {
                try {
                    tg.sendData(JSON.stringify({
                        action: 'player_move',
                        from: { row: fromRow, col: fromCol },
                        to: { row: toRow, col: toCol },
                        piece,
                        board: gameState.board
                    }));
                } catch (error) {
                    console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ö–æ–¥–∞:', error);
                }
            }
            
            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ö–æ–¥ –ò–ò
            setTimeout(requestAIMove, 500);
        }

        function requestAIMove() {
            if (gameState.currentTurn === gameState.playerColor) return;
            
            updateGameStatus();
            updateYakovComment("–†–∞–∑–º—ã—à–ª—è—é –Ω–∞–¥ —Å–ª–µ–¥—É—é—â–∏–º —Ö–æ–¥–æ–º... –ö–∞–∫ –≥–æ–≤–æ—Ä–∏—Ç—Å—è, –ø–æ—Å–ø–µ—à–∏—à—å - –ª—é–¥–µ–π –Ω–∞—Å–º–µ—à–∏—à—å!");
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ö–æ–¥ –ò–ò
            if (tg && tg.sendData) {
                try {
                    tg.sendData(JSON.stringify({
                        action: 'request_ai_move',
                        board: gameState.board,
                        difficulty: gameState.difficulty
                    }));
                } catch (error) {
                    console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —Ö–æ–¥–∞ –ò–ò:', error);
                }
            }
        }

        function handleAIMove(aiMoveData) {
            const { from, to, piece, comment, board } = aiMoveData;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ—Å–∫—É
            gameState.board = board;
            
            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ö–æ–¥ –ò–ò –≤ –∏—Å—Ç–æ—Ä–∏—é
            const moveNotation = `${String.fromCharCode(97 + from.col)}${8 - from.row}-${String.fromCharCode(97 + to.col)}${8 - to.row}`;
            gameState.moveHistory.push({
                notation: moveNotation,
                piece,
                captured: aiMoveData.captured,
                player: gameState.playerColor === 'white' ? 'black' : 'white'
            });
            
            // –û—á–∏—â–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –∏ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ö–æ–¥ –ò–ò
            clearHighlights();
            document.querySelector(`[data-row="${to.row}"][data-col="${to.col}"]`).classList.add('last-move');
            
            // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –¥–æ—Å–∫—É
            renderBoard();
            updateCapturedPieces();
            
            // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ö–æ–¥
            gameState.currentTurn = gameState.playerColor;
            updateGameStatus();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ø–∫–æ–≤–∞
            updateYakovComment(comment);
        }

        function updateGameStatus() {
            const statusEl = document.getElementById('game-status');
            
            if (gameState.currentTurn === gameState.playerColor) {
                statusEl.textContent = '–í–∞—à —Ö–æ–¥!';
                statusEl.className = 'game-status status-your-turn';
            } else {
                statusEl.textContent = '–•–æ–¥–∏—Ç –ò–ò...';
                statusEl.className = 'game-status status-ai-turn status-thinking';
            }
        }

        function updateCapturedPieces() {
            const playerCaptured = document.getElementById('player-captured');
            const aiCaptured = document.getElementById('ai-captured');
            
            const aiColor = gameState.playerColor === 'white' ? 'black' : 'white';
            
            playerCaptured.textContent = gameState.capturedPieces[aiColor].map(p => pieces[p]).join('');
            aiCaptured.textContent = gameState.capturedPieces[gameState.playerColor].map(p => pieces[p]).join('');
        }

        function updateYakovComment(comment) {
            document.getElementById('yakov-comment').innerHTML = `"${comment}"`;
        }

        function showMoveHistory() {
            const historyEl = document.getElementById('move-history');
            const moveListEl = document.getElementById('move-list');
            
            historyEl.classList.toggle('hidden');
            
            if (!historyEl.classList.contains('hidden')) {
                moveListEl.innerHTML = '';
                gameState.moveHistory.forEach((move, index) => {
                    const moveEl = document.createElement('div');
                    moveEl.className = 'move-item';
                    moveEl.textContent = `${Math.floor(index/2) + 1}. ${move.notation}`;
                    moveListEl.appendChild(moveEl);
                });
            }
        }

        function requestHint() {
            if (tg && tg.sendData) {
                try {
                    tg.sendData(JSON.stringify({
                        action: 'request_hint',
                        board: gameState.board,
                        playerColor: gameState.playerColor
                    }));
                } catch (error) {
                    console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –ø–æ–¥—Å–∫–∞–∑–∫–∏:', error);
                }
            }
        }

        function resignGame() {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–∞—Ç—å—Å—è?')) {
                gameState.gameStatus = 'finished';
                updateYakovComment("–ù–µ —Ä–∞—Å—Å—Ç—Ä–∞–∏–≤–∞–π—Ç–µ—Å—å, —Ç–æ–≤–∞—Ä–∏—â! –ö–∞–∫ –≥–æ–≤–æ—Ä–∏—Ç—Å—è, –∏ –Ω–∞ —Å—Ç–∞—Ä—É—Ö—É –±—ã–≤–∞–µ—Ç –ø—Ä–æ—Ä—É—Ö–∞. –ì–ª–∞–≤–Ω–æ–µ - —É—á–∏—Ç—å—Å—è –Ω–∞ –æ—à–∏–±–∫–∞—Ö!");
                
                if (tg && tg.sendData) {
                    try {
                        tg.sendData(JSON.stringify({
                            action: 'resign_game'
                        }));
                    } catch (error) {
                        console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–¥–∞—á–µ:', error);
                    }
                }
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –±–æ—Ç–∞
        tg.onEvent('mainButtonClicked', function() {
            tg.close();
        });

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω—É—é –∫–Ω–æ–ø–∫—É
        tg.MainButton.text = "–ó–∞–∫—Ä—ã—Ç—å –∏–≥—Ä—É";
        tg.MainButton.show();

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç Telegram Web App
        window.addEventListener('message', function(event) {
            if (event.data.type === 'ai_move') {
                handleAIMove(event.data.move);
            } else if (event.data.type === 'hint') {
                updateYakovComment(event.data.hint);
            }
        });
    </script>
</body>
</html>
